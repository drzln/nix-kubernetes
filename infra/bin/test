#!/usr/bin/env ruby
# frozen_string_literal: true

require 'json'
require 'optparse'
require 'aws-sdk-autoscaling'
require 'aws-sdk-ec2'
require 'net/ssh'
require 'time'

def log(msg) = warn("[#{Time.now.iso8601}] #{msg}")

def abort!(msg)
  log("ERROR: #{msg}")
  exit 1
end

# ─── CLI ─────────────────────────────────────────────────────
opts = { plan: 'plan.json', key: '~/.ssh/id_rsa', user: 'root', wait: 300 }
OptionParser.new do |o|
  o.on('-p', '--plan FILE')       { |v| opts[:plan] = v }
  o.on('-k', '--ssh-key PATH')    { |v| opts[:key]  = v }
  o.on('-u', '--user NAME')       { |v| opts[:user] = v }
  o.on('-w', '--wait SECS', Integer) { |v| opts[:wait] = v }
end.parse!

# ─── Parse plan (replace by your own JSON path/command) ─────
plan      = JSON.parse(`pangea show templates/network.rb`, symbolize_names: true)
asg_defs  = plan.dig(:resource, :aws_autoscaling_group) || {}
asg_names = asg_defs.keys
abort! 'No autoscaling groups in plan' if asg_names.empty?
log "Found ASGs: #{asg_names.join(', ')}"

region = ENV.fetch('AWS_REGION', 'us-east-1')
asg  = Aws::AutoScaling::Client.new(region:)
ec2  = Aws::EC2::Client.new(region:)

# ─── helpers ─────────────────────────────────────────────────
def scale_asg(client, name, size)
  client.update_auto_scaling_group(
    auto_scaling_group_name: name,
    min_size: size,
    max_size: size,
    desired_capacity: size
  )
end

# keep the *name* string separate from the response object  ↓↓↓
def wait_for_instance(asg, ec2, group_name, timeout)
  deadline = Time.now + timeout
  loop do
    resp = asg.describe_auto_scaling_groups(
      auto_scaling_group_names: [group_name]
    ).auto_scaling_groups.first

    inst_id = resp.instances.find { |i| i.lifecycle_state == 'InService' }&.instance_id
    if inst_id
      inst = ec2.describe_instances(instance_ids: [inst_id])
                .reservations[0].instances[0]
      ip   = inst.public_ip_address
      return [inst_id, ip] if ip
    end
    raise 'timeout' if Time.now > deadline

    sleep 5
  end
end

def probe_ssh(ip, user, key)
  Net::SSH.start(
    ip,
    user,
    keys: [File.expand_path(key)],
    non_interactive: true, timeout: 10
  ) { |ssh| ssh.exec!('hostname').strip }
end

# ─── main workflow ───────────────────────────────────────────
begin
  asg_names.each do |name|
    log "Scaling #{name} → 1"
    scale_asg(asg, name, 1)

    log 'Waiting for instance…'
    inst_id, ip = wait_for_instance(asg, ec2, name, opts[:wait])
    log "Instance #{inst_id} ready at #{ip}"

    log 'Probing SSH…'
    host = probe_ssh(ip, opts[:user], opts[:key]) or abort! "SSH failed to #{ip}"
    log "SSH OK: #{host}"
  end
  log 'All ASGs verified via SSH'

# ─── always scale back to zero ───────────────────────────────
ensure
  asg_names.each do |name|
    log "Tearing down – scaling #{name} → 0"
    begin
      scale_asg(asg, name, 0)
    rescue Aws::Errors::ServiceError => e
      log "Could not scale #{name} down: #{e.message}"
    end
  end
  log 'Cleanup complete (desired_capacity = 0 for all ASGs)'
end
