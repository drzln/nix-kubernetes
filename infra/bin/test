#!/usr/bin/env ruby
# frozen_string_literal: true

require 'json'
require 'optparse'
require 'aws-sdk-autoscaling'
require 'aws-sdk-ec2'
require 'net/ssh'
require 'time'

def log(msg) = warn("[#{Time.now.iso8601}] #{msg}")

def abort!(msg)
  log("ERROR: #{msg}")
  exit 1
end

# ─── CLI ─────────────────────────────────────────────────────
opts = { plan: 'plan.json', key: '~/.ssh/id_rsa', user: 'root', wait: 300 }
OptionParser.new do |o|
  o.on('-p', '--plan FILE')       { |v| opts[:plan] = v }
  o.on('-k', '--ssh-key PATH')    { |v| opts[:key]  = v }
  o.on('-u', '--user NAME')       { |v| opts[:user] = v }
  o.on('-w', '--wait SECS', Integer) { |v| opts[:wait] = v }
end.parse!

# ─── Parse plan (replace by your own JSON path/command) ─────
plan      = JSON.parse(`pangea show templates/network.rb`, symbolize_names: true)
asg_defs  = plan.dig(:resource, :aws_autoscaling_group) || {}
asg_names = asg_defs.keys
abort! 'No autoscaling groups in plan' if asg_names.empty?
log "Found ASGs: #{asg_names.join(', ')}"

region = ENV.fetch('AWS_REGION', 'us-east-1')
asg  = Aws::AutoScaling::Client.new(region:)
ec2  = Aws::EC2::Client.new(region:)

# ─── helpers ─────────────────────────────────────────────────
def scale_asg(client, name, size)
  client.update_auto_scaling_group(
    auto_scaling_group_name: name,
    min_size: size,
    max_size: size,
    desired_capacity: size
  )
end

# keep the *name* string separate from the response object  ↓↓↓
def wait_for_instance(asg, ec2, group_name, timeout)
  deadline = Time.now + timeout
  loop do
    resp = asg.describe_auto_scaling_groups(
      auto_scaling_group_names: [group_name]
    ).auto_scaling_groups.first

    inst_id = resp.instances.find { |i| i.lifecycle_state == 'InService' }&.instance_id
    if inst_id
      inst = ec2.describe_instances(instance_ids: [inst_id])
                .reservations[0].instances[0]
      ip   = inst.public_ip_address
      return [inst_id, ip] if ip
    end
    raise 'timeout' if Time.now > deadline

    sleep 5
  end
end

DEFAULT_USERS = %w[ec2-user ubuntu nixos root].freeze

def probe_ssh(ip, key_path:, users: DEFAULT_USERS, max_wait: 300)
  deadline   = Time.now + max_wait
  backoff    = 5 # first sleep in seconds
  last_error = nil
  attempt    = 0

  loop do
    users.each do |user|
      attempt += 1
      log "SSH-probe ##{attempt} → #{user}@#{ip} (timeout in #{(deadline - Time.now).to_i}s)"
      begin
        host = Net::SSH.start(
          ip, user,
          keys: [File.expand_path(key_path)],
          non_interactive: true,
          verify_host_key: :never, # ← no StrictHostKeyChecking
          auth_methods: %w[publickey],
          timeout: 10
        ) { |ssh| ssh.exec!('hostname').strip }

        log "SSH OK (#{user}@#{ip}) → host=#{host.inspect}"
        return host
      rescue Net::SSH::AuthenticationFailed => e
        log "Auth failed for #{user}@#{ip} (#{e.message})"
        last_error = e
      rescue Net::SSH::ConnectionTimeout,
             Net::SSH::Disconnect,
             Errno::ETIMEDOUT,
             SocketError => e
        log "SSH not ready yet: #{e.class} – will retry"
        last_error = e
      end
    end

    break if Time.now >= deadline

    sleep backoff
    backoff = [backoff * 1.5, 30].min # exponential up to 30 s
  end

  raise(last_error || "SSH timeout – #{ip} unreachable after #{max_wait}s")
end
# ─── main workflow ───────────────────────────────────────────
begin
  asg_names.each do |name|
    log "Scaling #{name} → 1"
    scale_asg(asg, name, 1)

    log 'Waiting for instance…'
    inst_id, ip = wait_for_instance(asg, ec2, name, opts[:wait])
    log "Instance #{inst_id} ready at #{ip}"

    log 'Probing SSH…'
    host = probe_ssh(ip, opts[:user], opts[:key]) or abort! "SSH failed to #{ip}"
    log "SSH OK: #{host}"
  end
  log 'All ASGs verified via SSH'
  system 'colmena build'
  system 'rm -rf dynamic-nodes.nix'
  system 'ruby fetch_ips.rb'
  system 'colmena apply'

# ─── always scale back to zero ───────────────────────────────
ensure
  # asg_names.each do |name|
  #   log "Tearing down – scaling #{name} → 0"
  #   begin
  #     scale_asg(asg, name, 0)
  #   rescue Aws::Errors::ServiceError => e
  #     log "Could not scale #{name} down: #{e.message}"
  #   end
  # end
  log 'Cleanup complete (desired_capacity = 0 for all ASGs)'
end
